import { AIRouter, RoutingRule } from '../AIRouter';
import { ProviderRegistry } from '../ProviderRegistry';
import { ConfigManager } from '../../config/ConfigManager';
import { AIProvider, AIRequest, ProviderConfig, AICapability } from '../../../shared/types/AI';

// Mock provider classes for testing
class MockCowriterProvider implements AIProvider {
  readonly id = 'cowriter-1';
  readonly name = 'SoYume Co-writer';
  readonly type = 'cowriter' as const;
  readonly version = '1.0.0';
  readonly capabilities: AICapability[] = [
    { name: 'outline_generation', description: 'Generate story outlines' },
    { name: 'character_analysis', description: 'Analyze characters' },
    { name: 'story_analysis', description: 'Analyze story structure' }
  ];
  readonly priority = 10;
  readonly metadata = {
    description: 'Specialized creative writing AI',
    author: 'SoYume',
    supportedLanguages: ['en'],
    requirements: {
      internetRequired: false,
      apiKeyRequired: false
    }
  };

  async initialize(config: ProviderConfig): Promise<void> {}
  async shutdown(): Promise<void> {}
  isAvailable(): boolean { return true; }
  getStatus() {
    return {
      state: 'ready' as const,
      uptime: 1000,
      requestCount: 0,
      averageResponseTime: 50
    };
  }
  async healthCheck() {
    return { healthy: true, responseTime: 50 };
  }
  getUsageStats() {
    return {
      totalRequests: 5,
      successfulRequests: 5,
      failedRequests: 0,
      averageResponseTime: 50,
      totalTokensUsed: 100,
      requestsByType: {},
      lastUsed: new Date()
    };
  }
  async updateConfig(config: Partial<ProviderConfig>): Promise<void> {}
  getConfig(): ProviderConfig { return {}; }

  async generateText(prompt: string, context: any) {
    return {
      content: `Cowriter: ${prompt}`,
      confidence: 0.9,
      metadata: { model: this.name, provider: this.name, tokensUsed: 10, responseTime: 50 }
    };
  }

  async analyzeStory(content: string) {
    return {
      structure: { identifiedStructure: 'three-act', completedBeats: [], missingBeats: [], suggestions: [], confidence: 0.9 },
      characters: { consistencyScore: 0.9, voiceConsistency: 0.9, developmentProgress: 0.9, relationshipHealth: [], suggestions: [] },
      pacing: { overallPacing: 'good', tensionCurve: [], recommendations: [] },
      consistency: { overallScore: 0.9, plotHoles: [], characterInconsistencies: [], worldBuildingIssues: [] },
      overallScore: 0.9,
      recommendations: []
    };
  }

  async generateCharacter(traits: any) {
    return {
      id: 'cowriter-char',
      name: 'Cowriter Character',
      archetype: { primary: 'hero', description: 'Generated by cowriter', commonTraits: [] },
      traits: { personality: [], motivations: [], fears: [], strengths: [], weaknesses: [], quirks: [] },
      relationships: [],
      developmentArc: { startState: '', endState: '', keyMoments: [], completed: false },
      voiceProfile: { vocabulary: [], speechPatterns: [], commonPhrases: [], formalityLevel: 5, emotionalRange: [] }
    };
  }
}

class MockCloudProvider implements AIProvider {
  readonly id = 'cloud-1';
  readonly name = 'OpenAI GPT-4';
  readonly type = 'cloud' as const;
  readonly version = '1.0.0';
  readonly capabilities: AICapability[] = [
    { name: 'text_generation', description: 'Generate text' },
    { name: 'research', description: 'Research capabilities' }
  ];
  readonly priority = 8;
  readonly metadata = {
    description: 'OpenAI GPT-4 provider',
    author: 'OpenAI',
    supportedLanguages: ['en'],
    requirements: {
      internetRequired: true,
      apiKeyRequired: true
    }
  };

  async initialize(config: ProviderConfig): Promise<void> {}
  async shutdown(): Promise<void> {}
  isAvailable(): boolean { return true; }
  getStatus() {
    return {
      state: 'ready' as const,
      uptime: 1000,
      requestCount: 0,
      averageResponseTime: 200
    };
  }
  async healthCheck() {
    return { healthy: true, responseTime: 200 };
  }
  getUsageStats() {
    return {
      totalRequests: 10,
      successfulRequests: 9,
      failedRequests: 1,
      averageResponseTime: 200,
      totalTokensUsed: 500,
      requestsByType: {},
      lastUsed: new Date()
    };
  }
  async updateConfig(config: Partial<ProviderConfig>): Promise<void> {}
  getConfig(): ProviderConfig { return {}; }

  async generateText(prompt: string, context: any) {
    return {
      content: `Cloud: ${prompt}`,
      confidence: 0.85,
      metadata: { model: this.name, provider: this.name, tokensUsed: 20, responseTime: 200 }
    };
  }

  async analyzeStory(content: string) {
    return {
      structure: { identifiedStructure: 'hero-journey', completedBeats: [], missingBeats: [], suggestions: [], confidence: 0.85 },
      characters: { consistencyScore: 0.85, voiceConsistency: 0.85, developmentProgress: 0.85, relationshipHealth: [], suggestions: [] },
      pacing: { overallPacing: 'good', tensionCurve: [], recommendations: [] },
      consistency: { overallScore: 0.85, plotHoles: [], characterInconsistencies: [], worldBuildingIssues: [] },
      overallScore: 0.85,
      recommendations: []
    };
  }

  async generateCharacter(traits: any) {
    return {
      id: 'cloud-char',
      name: 'Cloud Character',
      archetype: { primary: 'mentor', description: 'Generated by cloud AI', commonTraits: [] },
      traits: { personality: [], motivations: [], fears: [], strengths: [], weaknesses: [], quirks: [] },
      relationships: [],
      developmentArc: { startState: '', endState: '', keyMoments: [], completed: false },
      voiceProfile: { vocabulary: [], speechPatterns: [], commonPhrases: [], formalityLevel: 5, emotionalRange: [] }
    };
  }
}

// Mock ConfigManager
class MockConfigManager extends ConfigManager {
  private cloudAllowed = true;

  getEnabledProviders() {
    return [];
  }

  isCloudAIAllowed(): boolean {
    return this.cloudAllowed;
  }

  setCloudAllowed(allowed: boolean) {
    this.cloudAllowed = allowed;
  }

  get(key: string): any {
    return undefined;
  }

  set(key: string, value: any): void {}
}

describe('AIRouter', () => {
  let router: AIRouter;
  let registry: ProviderRegistry;
  let configManager: MockConfigManager;
  let cowriterProvider: MockCowriterProvider;
  let cloudProvider: MockCloudProvider;

  beforeEach(async () => {
    configManager = new MockConfigManager();
    registry = new ProviderRegistry(configManager);
    router = new AIRouter(registry, configManager);
    
    cowriterProvider = new MockCowriterProvider();
    cloudProvider = new MockCloudProvider();

    await registry.initialize();
    await registry.registerProvider(cowriterProvider, {});
    await registry.registerProvider(cloudProvider, {});
  });

  afterEach(async () => {
    await registry.shutdown();
  });

  describe('request routing', () => {
    it('should route creative tasks to cowriter AI', async () => {
      const request: AIRequest = {
        type: 'character_analysis',
        content: 'Analyze this character',
        context: { characters: [], genre: [], targetAudience: '' }
      };

      const provider = await router.routeRequest(request);
      expect(provider.type).toBe('cowriter');
      expect(provider.name).toBe('SoYume Co-writer');
    });

    it('should route prose generation to cloud AI', async () => {
      const request: AIRequest = {
        type: 'prose_generation',
        content: 'Write a story',
        context: { characters: [], genre: [], targetAudience: '' }
      };

      const provider = await router.routeRequest(request);
      expect(provider.type).toBe('cloud');
      expect(provider.name).toBe('OpenAI GPT-4');
    });

    it('should respect preferred provider in request options', async () => {
      const request: AIRequest = {
        type: 'prose_generation',
        content: 'Write a story',
        context: { characters: [], genre: [], targetAudience: '' },
        options: {
          preferredProvider: 'SoYume Co-writer'
        }
      };

      const provider = await router.routeRequest(request);
      expect(provider.name).toBe('SoYume Co-writer');
    });

    it('should filter out cloud providers when offline required', async () => {
      const request: AIRequest = {
        type: 'prose_generation',
        content: 'Write a story',
        context: { characters: [], genre: [], targetAudience: '' },
        options: {
          requireOffline: true
        }
      };

      const provider = await router.routeRequest(request);
      expect(provider.type).not.toBe('cloud');
      expect(provider.name).toBe('SoYume Co-writer');
    });

    it('should filter out cloud providers when cloud AI is disabled', async () => {
      configManager.setCloudAllowed(false);

      const request: AIRequest = {
        type: 'prose_generation',
        content: 'Write a story',
        context: { characters: [], genre: [], targetAudience: '' }
      };

      const provider = await router.routeRequest(request);
      expect(provider.type).not.toBe('cloud');
    });

    it('should throw error when no suitable provider found', async () => {
      // Disable all providers\n      await registry.disableProvider(cowriterProvider.name);
      await registry.disableProvider(cloudProvider.name);

      const request: AIRequest = {
        type: 'prose_generation',
        content: 'Write a story',
        context: { characters: [], genre: [], targetAudience: '' }
      };

      await expect(router.routeRequest(request)).rejects.toThrow('No suitable provider found');
    });
  });

  describe('routing configuration', () => {
    it('should add custom routing rule', () => {
      const rule: RoutingRule = {
        requestType: 'research',
        preferredProviderType: 'cloud',
        fallbackStrategy: 'priority'
      };

      router.addRoutingRule(rule);
      const config = router.getRoutingConfig();
      
      const addedRule = config.rules.find(r => r.requestType === 'research');
      expect(addedRule).toBeDefined();
      expect(addedRule?.preferredProviderType).toBe('cloud');
    });

    it('should remove routing rule', () => {
      router.removeRoutingRule('outline');
      const config = router.getRoutingConfig();
      
      const removedRule = config.rules.find(r => r.requestType === 'outline');
      expect(removedRule).toBeUndefined();
    });

    it('should update routing configuration', () => {
      router.updateRoutingConfig({
        defaultStrategy: 'load_balance',
        maxRetries: 5
      });

      const config = router.getRoutingConfig();
      expect(config.defaultStrategy).toBe('load_balance');
      expect(config.maxRetries).toBe(5);
    });
  });

  describe('provider testing', () => {
    it('should test individual provider', async () => {
      const result = await router.testProvider(cowriterProvider.name);
      
      expect(result.success).toBe(true);
      expect(result.responseTime).toBeGreaterThan(0);
      expect(result.error).toBeUndefined();
    });

    it('should test all providers', async () => {
      const results = await router.testAllProviders();
      
      expect(results.size).toBe(2);
      expect(results.get(cowriterProvider.name)?.success).toBe(true);
      expect(results.get(cloudProvider.name)?.success).toBe(true);
    });

    it('should handle provider test failure', async () => {
      const result = await router.testProvider('nonexistent-provider');
      
      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('provider recommendations', () => {
    it('should recommend appropriate provider for request type', () => {
      const recommendation = router.recommendProvider('character_analysis');
      
      expect(recommendation.recommended).toBe('SoYume Co-writer');
      expect(recommendation.alternatives).toContain('OpenAI GPT-4');
      expect(recommendation.reasoning).toContain('priority strategy');
    });

    it('should handle no available providers', async () => {
      await registry.disableProvider(cowriterProvider.name);
      await registry.disableProvider(cloudProvider.name);

      const recommendation = router.recommendProvider('character_analysis');
      
      expect(recommendation.recommended).toBeNull();
      expect(recommendation.alternatives).toHaveLength(0);
      expect(recommendation.reasoning).toBe('No suitable providers available');
    });
  });

  describe('usage statistics', () => {
    it('should get provider usage stats', () => {
      const stats = router.getProviderUsageStats();
      
      expect(stats.size).toBe(2);
      expect(stats.get(cowriterProvider.name)).toBeDefined();
      expect(stats.get(cloudProvider.name)).toBeDefined();
    });

    it('should include success rate in stats', () => {
      const stats = router.getProviderUsageStats();
      const cowriterStats = stats.get(cowriterProvider.name);
      
      expect(cowriterStats.successRate).toBe(100); // 5/5 successful requests
      
      const cloudStats = stats.get(cloudProvider.name);
      expect(cloudStats.successRate).toBe(90); // 9/10 successful requests
    });
  });

  describe('request execution with retries', () => {
    it('should execute request successfully', async () => {
      const request: AIRequest = {
        type: 'character_analysis',
        content: 'Test character',
        context: { characters: [], genre: [], targetAudience: '' }
      };

      const response = await router.executeRequest(request);
      expect(response.content).toContain('Cowriter: Test character');
    });

    it('should retry on failure when fallback enabled', async () => {
      // This test would require mocking provider failures
      // For now, we'll test the basic execution path
      const request: AIRequest = {
        type: 'prose_generation',
        content: 'Test story',
        context: { characters: [], genre: [], targetAudience: '' }
      };

      const response = await router.executeRequest(request);
      expect(response.content).toContain('Cloud: Test story');
    });
  });

  describe('provider priority management', () => {
    it('should update provider priority', () => {
      const originalPriority = cowriterProvider.priority;
      router.setProviderPriority(cowriterProvider.name, 15);
      
      expect(cowriterProvider.priority).toBe(15);
      expect(cowriterProvider.priority).not.toBe(originalPriority);
    });

    it('should handle setting priority for nonexistent provider', () => {
      // Should not throw error
      expect(() => {
        router.setProviderPriority('nonexistent', 10);
      }).not.toThrow();
    });
  });
});