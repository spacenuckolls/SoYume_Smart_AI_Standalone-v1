import { Story, Scene, Character, PlotHole, PlotThread, StoryElement } from '../../shared/types/Story';

export interface PlotHoleAnalysisResult {
  plotHoles: PlotHole[];
  plotThreads: PlotThread[];
  continuityIssues: ContinuityIssue[];
  characterInconsistencies: CharacterInconsistency[];
  suggestions: PlotHoleSuggestion[];
  overallScore: number;
}

export interface ContinuityIssue {
  id: string;
  type: 'timeline' | 'location' | 'object' | 'ability' | 'knowledge';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  scenes: number[];
  conflictingElements: string[];
  suggestions: string[];
}

export interface CharacterInconsistency {
  id: string;
  characterId: string;
  characterName: string;
  type: 'personality' | 'motivation' | 'ability' | 'knowledge' | 'relationship';
  severity: 'low' | 'medium' | 'high';
  description: string;
  scenes: number[];
  conflictingTraits: string[];
  suggestions: string[];
}

export interface PlotHoleSuggestion {
  id: string;
  type: 'add_scene' | 'modify_scene' | 'add_dialogue' | 'character_development' | 'world_building';
  priority: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  targetScene?: number;
  implementation: string[];
  relatedPlotHoles: string[];
}

export interface PlotThreadTracker {
  id: string;
  name: string;
  description: string;
  introduced: number; // Scene index
  resolved?: number; // Scene index
  status: 'active' | 'resolved' | 'abandoned' | 'forgotten';
  importance: 'major' | 'minor' | 'subplot';
  relatedCharacters: string[];
  keyScenes: number[];
}

export class PlotHoleDetector {
  private plotThreads: Map<string, PlotThreadTracker> = new Map();
  private characterStates: Map<string, CharacterStateTracker> = new Map();
  private worldElements: Map<string, WorldElementTracker> = new Map();
  private timelineEvents: TimelineEvent[] = [];

  async analyzeStoryForPlotHoles(story: Story): Promise<PlotHoleAnalysisResult> {
    // Initialize tracking systems
    await this.initializeTrackers(story);
    
    // Analyze each scene sequentially
    const scenes = story.scenes || [];
    for (let i = 0; i < scenes.length; i++) {
      await this.analyzeScene(scenes[i], i, story);
    }
    
    // Detect plot holes and inconsistencies
    const plotHoles = await this.detectPlotHoles();
    const plotThreads = Array.from(this.plotThreads.values()).map(this.convertToPlotThread);
    const continuityIssues = await this.detectContinuityIssues();
    const characterInconsistencies = await this.detectCharacterInconsistencies();
    const suggestions = await this.generateSuggestions(plotHoles, continuityIssues, characterInconsistencies);
    
    // Calculate overall story consistency score
    const overallScore = this.calculateConsistencyScore(plotHoles, continuityIssues, characterInconsistencies);
    
    return {
      plotHoles,
      plotThreads,
      continuityIssues,
      characterInconsistencies,
      suggestions,
      overallScore
    };
  }

  private async initializeTrackers(story: Story): Promise<void> {
    // Initialize character trackers
    const characters = story.characters || [];
    for (const character of characters) {
      this.characterStates.set(character.id, new CharacterStateTracker(character));
    }
    
    // Initialize world element trackers
    await this.initializeWorldElements(story);
    
    // Clear previous analysis data
    this.plotThreads.clear();
    this.timelineEvents = [];
  }

  private async initializeWorldElements(story: Story): Promise<void> {
    // Extract world elements from story metadata and scenes
    const worldElements = new Set<string>();
    
    // Add elements from story settings
    if (story.setting) {
      worldElements.add(story.setting);
    }
    
    // Extract elements from scenes
    const scenes = story.scenes || [];
    for (const scene of scenes) {
      const elements = await this.extractWorldElements(scene);
      elements.forEach(element => worldElements.add(element));
    }
    
    // Initialize trackers for each world element
    for (const element of worldElements) {
      this.worldElements.set(element, new WorldElementTracker(element));
    }
  }

  private async extractWorldElements(scene: Scene): Promise<string[]> {
    const content = scene.content || '';
    const elements: string[] = [];
    
    // Extract locations
    const locationPatterns = [
      /(?:in|at|to|from)\s+(?:the\s+)?([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)/g,
      /\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\s+(?:building|house|room|city|town|forest|mountain)/g
    ];
    
    for (const pattern of locationPatterns) {
      let match;
      while ((match = pattern.exec(content)) !== null) {\n        elements.push(match[1]);\n      }\n    }\n    \n    // Extract objects and artifacts\n    const objectPatterns = [\n      /\\b(?:the\\s+)?([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*)\\s+(?:sword|ring|book|scroll|artifact|weapon|tool)/g,\n      /\\b(?:magic|magical|enchanted|cursed)\\s+([a-z]+(?:\\s+[a-z]+)*)/g\n    ];\n    \n    for (const pattern of objectPatterns) {\n      let match;\n      while ((match = pattern.exec(content)) !== null) {\n        elements.push(match[1]);\n      }\n    }\n    \n    return elements;\n  }\n\n  private async analyzeScene(scene: Scene, sceneIndex: number, story: Story): Promise<void> {\n    const content = scene.content || '';\n    \n    // Track plot threads\n    await this.trackPlotThreads(scene, sceneIndex, content);\n    \n    // Update character states\n    await this.updateCharacterStates(scene, sceneIndex, content, story.characters || []);\n    \n    // Track world elements\n    await this.trackWorldElements(scene, sceneIndex, content);\n    \n    // Record timeline events\n    await this.recordTimelineEvents(scene, sceneIndex, content);\n  }\n\n  private async trackPlotThreads(scene: Scene, sceneIndex: number, content: string): Promise<void> {\n    // Detect new plot threads being introduced\n    const newThreads = await this.detectNewPlotThreads(content, sceneIndex);\n    for (const thread of newThreads) {\n      this.plotThreads.set(thread.id, thread);\n    }\n    \n    // Update existing plot threads\n    for (const [threadId, thread] of this.plotThreads) {\n      const isReferenced = await this.isPlotThreadReferenced(content, thread);\n      if (isReferenced) {\n        thread.keyScenes.push(sceneIndex);\n        \n        // Check if thread is being resolved\n        const isResolved = await this.isPlotThreadResolved(content, thread);\n        if (isResolved && thread.status === 'active') {\n          thread.resolved = sceneIndex;\n          thread.status = 'resolved';\n        }\n      }\n    }\n  }\n\n  private async detectNewPlotThreads(content: string, sceneIndex: number): Promise<PlotThreadTracker[]> {\n    const threads: PlotThreadTracker[] = [];\n    \n    // Detect mystery/question introductions\n    const mysteryPatterns = [\n      /(?:what|who|why|how|where|when)\\s+(?:is|was|did|happened|caused)/gi,\n      /(?:mystery|secret|hidden|unknown|missing)/gi,\n      /(?:must find|need to discover|have to learn)/gi\n    ];\n    \n    for (const pattern of mysteryPatterns) {\n      const matches = content.match(pattern);\n      if (matches) {\n        for (const match of matches) {\n          const threadId = `mystery_${sceneIndex}_${threads.length}`;\n          threads.push({\n            id: threadId,\n            name: `Mystery: ${match}`,\n            description: `Plot thread introduced in scene ${sceneIndex}: ${match}`,\n            introduced: sceneIndex,\n            status: 'active',\n            importance: 'major',\n            relatedCharacters: [],\n            keyScenes: [sceneIndex]\n          });\n        }\n      }\n    }\n    \n    // Detect conflict introductions\n    const conflictPatterns = [\n      /(?:conflict|fight|battle|war|struggle|oppose)/gi,\n      /(?:enemy|villain|antagonist|rival)/gi,\n      /(?:must stop|have to prevent|need to defeat)/gi\n    ];\n    \n    for (const pattern of conflictPatterns) {\n      const matches = content.match(pattern);\n      if (matches) {\n        for (const match of matches) {\n          const threadId = `conflict_${sceneIndex}_${threads.length}`;\n          threads.push({\n            id: threadId,\n            name: `Conflict: ${match}`,\n            description: `Conflict thread introduced in scene ${sceneIndex}: ${match}`,\n            introduced: sceneIndex,\n            status: 'active',\n            importance: 'major',\n            relatedCharacters: [],\n            keyScenes: [sceneIndex]\n          });\n        }\n      }\n    }\n    \n    return threads;\n  }\n\n  private async isPlotThreadReferenced(content: string, thread: PlotThreadTracker): Promise<boolean> {\n    const threadKeywords = thread.name.toLowerCase().split(/\\s+/);\n    const contentLower = content.toLowerCase();\n    \n    // Check if any thread keywords appear in the content\n    return threadKeywords.some(keyword => contentLower.includes(keyword));\n  }\n\n  private async isPlotThreadResolved(content: string, thread: PlotThreadTracker): Promise<boolean> {\n    const resolutionPatterns = [\n      /(?:solved|resolved|answered|discovered|found|defeated|stopped)/gi,\n      /(?:finally|at last|in the end|ultimately)/gi,\n      /(?:mystery.*solved|question.*answered|conflict.*resolved)/gi\n    ];\n    \n    for (const pattern of resolutionPatterns) {\n      if (pattern.test(content)) {\n        // Check if the resolution relates to this thread\n        const threadKeywords = thread.name.toLowerCase().split(/\\s+/);\n        const contentLower = content.toLowerCase();\n        \n        if (threadKeywords.some(keyword => contentLower.includes(keyword))) {\n          return true;\n        }\n      }\n    }\n    \n    return false;\n  }\n\n  private async updateCharacterStates(scene: Scene, sceneIndex: number, content: string, characters: Character[]): Promise<void> {\n    for (const character of characters) {\n      const tracker = this.characterStates.get(character.id);\n      if (!tracker) continue;\n      \n      // Check if character is present in scene\n      const isPresent = await this.isCharacterPresent(content, character);\n      if (isPresent) {\n        tracker.recordPresence(sceneIndex);\n        \n        // Update character knowledge\n        await this.updateCharacterKnowledge(tracker, content, sceneIndex);\n        \n        // Update character abilities\n        await this.updateCharacterAbilities(tracker, content, sceneIndex);\n        \n        // Update character relationships\n        await this.updateCharacterRelationships(tracker, content, sceneIndex, characters);\n      }\n    }\n  }\n\n  private async isCharacterPresent(content: string, character: Character): Promise<boolean> {\n    const names = [character.name, ...(character.aliases || [])];\n    const contentLower = content.toLowerCase();\n    \n    return names.some(name => contentLower.includes(name.toLowerCase()));\n  }\n\n  private async updateCharacterKnowledge(tracker: CharacterStateTracker, content: string, sceneIndex: number): Promise<void> {\n    // Detect knowledge acquisition patterns\n    const knowledgePatterns = [\n      /(?:learned|discovered|found out|realized|understood)\\s+(?:that\\s+)?([^.!?]+)/gi,\n      /(?:knows|aware|informed)\\s+(?:that\\s+)?([^.!?]+)/gi\n    ];\n    \n    for (const pattern of knowledgePatterns) {\n      let match;\n      while ((match = pattern.exec(content)) !== null) {\n        tracker.addKnowledge(match[1].trim(), sceneIndex);\n      }\n    }\n  }\n\n  private async updateCharacterAbilities(tracker: CharacterStateTracker, content: string, sceneIndex: number): Promise<void> {\n    // Detect ability demonstrations or acquisitions\n    const abilityPatterns = [\n      /(?:can|able to|capable of)\\s+([^.!?]+)/gi,\n      /(?:learned to|mastered|gained the ability)\\s+([^.!?]+)/gi,\n      /(?:cast|performed|used)\\s+([^.!?]+)/gi\n    ];\n    \n    for (const pattern of abilityPatterns) {\n      let match;\n      while ((match = pattern.exec(content)) !== null) {\n        tracker.addAbility(match[1].trim(), sceneIndex);\n      }\n    }\n  }\n\n  private async updateCharacterRelationships(tracker: CharacterStateTracker, content: string, sceneIndex: number, characters: Character[]): Promise<void> {\n    // Detect relationship changes\n    const relationshipPatterns = [\n      /(?:loves|hates|trusts|distrusts|befriends|betrays)\\s+([A-Z][a-z]+)/gi,\n      /(?:ally|enemy|friend|rival)\\s+(?:of\\s+)?([A-Z][a-z]+)/gi\n    ];\n    \n    for (const pattern of relationshipPatterns) {\n      let match;\n      while ((match = pattern.exec(content)) !== null) {\n        const otherCharacterName = match[1];\n        const otherCharacter = characters.find(c => \n          c.name.toLowerCase() === otherCharacterName.toLowerCase() ||\n          (c.aliases || []).some(alias => alias.toLowerCase() === otherCharacterName.toLowerCase())\n        );\n        \n        if (otherCharacter) {\n          tracker.updateRelationship(otherCharacter.id, content, sceneIndex);\n        }\n      }\n    }\n  }\n\n  private async trackWorldElements(scene: Scene, sceneIndex: number, content: string): Promise<void> {\n    for (const [elementName, tracker] of this.worldElements) {\n      if (content.toLowerCase().includes(elementName.toLowerCase())) {\n        tracker.recordAppearance(sceneIndex, content);\n      }\n    }\n  }\n\n  private async recordTimelineEvents(scene: Scene, sceneIndex: number, content: string): Promise<void> {\n    // Extract temporal references\n    const timePatterns = [\n      /(?:after|before|during|while|when)\\s+([^.!?]+)/gi,\n      /(?:yesterday|today|tomorrow|last week|next month)/gi,\n      /(?:\\d+)\\s+(?:days|weeks|months|years)\\s+(?:ago|later)/gi\n    ];\n    \n    for (const pattern of timePatterns) {\n      let match;\n      while ((match = pattern.exec(content)) !== null) {\n        this.timelineEvents.push({\n          sceneIndex,\n          description: match[0],\n          type: 'temporal_reference',\n          timestamp: this.extractTimestamp(match[0])\n        });\n      }\n    }\n  }\n\n  private extractTimestamp(timeReference: string): number {\n    // Simple timestamp extraction - in a real implementation, this would be more sophisticated\n    const lowerRef = timeReference.toLowerCase();\n    \n    if (lowerRef.includes('ago')) {\n      const match = lowerRef.match(/(\\d+)\\s+(?:days|weeks|months|years)\\s+ago/);\n      if (match) {\n        const amount = parseInt(match[1]);\n        if (lowerRef.includes('days')) return -amount;\n        if (lowerRef.includes('weeks')) return -amount * 7;\n        if (lowerRef.includes('months')) return -amount * 30;\n        if (lowerRef.includes('years')) return -amount * 365;\n      }\n    }\n    \n    if (lowerRef.includes('later')) {\n      const match = lowerRef.match(/(\\d+)\\s+(?:days|weeks|months|years)\\s+later/);\n      if (match) {\n        const amount = parseInt(match[1]);\n        if (lowerRef.includes('days')) return amount;\n        if (lowerRef.includes('weeks')) return amount * 7;\n        if (lowerRef.includes('months')) return amount * 30;\n        if (lowerRef.includes('years')) return amount * 365;\n      }\n    }\n    \n    return 0; // Present time\n  }\n\n  private async detectPlotHoles(): Promise<PlotHole[]> {\n    const plotHoles: PlotHole[] = [];\n    \n    // Detect unresolved plot threads\n    for (const [threadId, thread] of this.plotThreads) {\n      if (thread.status === 'active' && thread.importance === 'major') {\n        plotHoles.push({\n          id: `unresolved_${threadId}`,\n          type: 'unresolved_thread',\n          severity: 'high',\n          description: `Major plot thread \"${thread.name}\" introduced in scene ${thread.introduced} but never resolved`,\n          scenes: thread.keyScenes,\n          suggestions: [\n            `Add a resolution scene for the ${thread.name} plot thread`,\n            'Provide closure or explanation for this story element',\n            'Consider if this thread is necessary for the story'\n          ]\n        });\n      }\n    }\n    \n    // Detect character knowledge inconsistencies\n    for (const [characterId, tracker] of this.characterStates) {\n      const inconsistencies = tracker.detectKnowledgeInconsistencies();\n      for (const inconsistency of inconsistencies) {\n        plotHoles.push({\n          id: `knowledge_${characterId}_${plotHoles.length}`,\n          type: 'character_knowledge',\n          severity: 'medium',\n          description: `Character ${tracker.character.name} ${inconsistency.description}`,\n          scenes: inconsistency.scenes,\n          suggestions: [\n            'Add a scene showing how the character acquired this knowledge',\n            'Remove the knowledge reference if it\\'s not needed',\n            'Establish the knowledge earlier in the story'\n          ]\n        });\n      }\n    }\n    \n    // Detect ability inconsistencies\n    for (const [characterId, tracker] of this.characterStates) {\n      const inconsistencies = tracker.detectAbilityInconsistencies();\n      for (const inconsistency of inconsistencies) {\n        plotHoles.push({\n          id: `ability_${characterId}_${plotHoles.length}`,\n          type: 'character_ability',\n          severity: 'medium',\n          description: `Character ${tracker.character.name} ${inconsistency.description}`,\n          scenes: inconsistency.scenes,\n          suggestions: [\n            'Show the character learning or acquiring this ability',\n            'Establish the ability earlier in the story',\n            'Provide explanation for the ability\\'s sudden appearance'\n          ]\n        });\n      }\n    }\n    \n    return plotHoles;\n  }\n\n  private async detectContinuityIssues(): Promise<ContinuityIssue[]> {\n    const issues: ContinuityIssue[] = [];\n    \n    // Detect timeline inconsistencies\n    const timelineIssues = this.detectTimelineInconsistencies();\n    issues.push(...timelineIssues);\n    \n    // Detect world element inconsistencies\n    const worldIssues = this.detectWorldElementInconsistencies();\n    issues.push(...worldIssues);\n    \n    return issues;\n  }\n\n  private detectTimelineInconsistencies(): ContinuityIssue[] {\n    const issues: ContinuityIssue[] = [];\n    \n    // Sort timeline events by scene index\n    const sortedEvents = [...this.timelineEvents].sort((a, b) => a.sceneIndex - b.sceneIndex);\n    \n    // Check for temporal contradictions\n    for (let i = 0; i < sortedEvents.length - 1; i++) {\n      const currentEvent = sortedEvents[i];\n      const nextEvent = sortedEvents[i + 1];\n      \n      // Check if timestamps are inconsistent with scene order\n      if (currentEvent.timestamp > nextEvent.timestamp && \n          currentEvent.sceneIndex < nextEvent.sceneIndex) {\n        issues.push({\n          id: `timeline_${i}`,\n          type: 'timeline',\n          severity: 'medium',\n          description: `Timeline inconsistency between scenes ${currentEvent.sceneIndex} and ${nextEvent.sceneIndex}`,\n          scenes: [currentEvent.sceneIndex, nextEvent.sceneIndex],\n          conflictingElements: [currentEvent.description, nextEvent.description],\n          suggestions: [\n            'Adjust the temporal references to maintain chronological order',\n            'Add clarifying information about the timeline',\n            'Consider using flashbacks or flash-forwards explicitly'\n          ]\n        });\n      }\n    }\n    \n    return issues;\n  }\n\n  private detectWorldElementInconsistencies(): ContinuityIssue[] {\n    const issues: ContinuityIssue[] = [];\n    \n    for (const [elementName, tracker] of this.worldElements) {\n      const inconsistencies = tracker.detectInconsistencies();\n      for (const inconsistency of inconsistencies) {\n        issues.push({\n          id: `world_${elementName}_${issues.length}`,\n          type: 'object',\n          severity: inconsistency.severity,\n          description: `World element \"${elementName}\" ${inconsistency.description}`,\n          scenes: inconsistency.scenes,\n          conflictingElements: inconsistency.conflictingDescriptions,\n          suggestions: [\n            'Ensure consistent descriptions of world elements',\n            'Establish clear rules for how world elements work',\n            'Remove contradictory information'\n          ]\n        });\n      }\n    }\n    \n    return issues;\n  }\n\n  private async detectCharacterInconsistencies(): Promise<CharacterInconsistency[]> {\n    const inconsistencies: CharacterInconsistency[] = [];\n    \n    for (const [characterId, tracker] of this.characterStates) {\n      // Detect personality inconsistencies\n      const personalityIssues = tracker.detectPersonalityInconsistencies();\n      for (const issue of personalityIssues) {\n        inconsistencies.push({\n          id: `personality_${characterId}_${inconsistencies.length}`,\n          characterId,\n          characterName: tracker.character.name,\n          type: 'personality',\n          severity: issue.severity,\n          description: issue.description,\n          scenes: issue.scenes,\n          conflictingTraits: issue.conflictingTraits,\n          suggestions: [\n            'Ensure character actions align with established personality',\n            'Provide character development to explain personality changes',\n            'Review character consistency across scenes'\n          ]\n        });\n      }\n      \n      // Detect motivation inconsistencies\n      const motivationIssues = tracker.detectMotivationInconsistencies();\n      for (const issue of motivationIssues) {\n        inconsistencies.push({\n          id: `motivation_${characterId}_${inconsistencies.length}`,\n          characterId,\n          characterName: tracker.character.name,\n          type: 'motivation',\n          severity: issue.severity,\n          description: issue.description,\n          scenes: issue.scenes,\n          conflictingTraits: issue.conflictingMotivations,\n          suggestions: [\n            'Clarify character motivations and goals',\n            'Show character growth that explains motivation changes',\n            'Ensure actions are consistent with stated motivations'\n          ]\n        });\n      }\n    }\n    \n    return inconsistencies;\n  }\n\n  private async generateSuggestions(\n    plotHoles: PlotHole[],\n    continuityIssues: ContinuityIssue[],\n    characterInconsistencies: CharacterInconsistency[]\n  ): Promise<PlotHoleSuggestion[]> {\n    const suggestions: PlotHoleSuggestion[] = [];\n    \n    // Generate suggestions for plot holes\n    for (const plotHole of plotHoles) {\n      const suggestion: PlotHoleSuggestion = {\n        id: `suggestion_${plotHole.id}`,\n        type: this.getSuggestionType(plotHole.type),\n        priority: this.mapSeverityToPriority(plotHole.severity),\n        description: `Address ${plotHole.type}: ${plotHole.description}`,\n        targetScene: plotHole.scenes[0],\n        implementation: plotHole.suggestions,\n        relatedPlotHoles: [plotHole.id]\n      };\n      suggestions.push(suggestion);\n    }\n    \n    // Generate suggestions for continuity issues\n    for (const issue of continuityIssues) {\n      const suggestion: PlotHoleSuggestion = {\n        id: `suggestion_${issue.id}`,\n        type: 'modify_scene',\n        priority: this.mapSeverityToPriority(issue.severity),\n        description: `Fix continuity issue: ${issue.description}`,\n        targetScene: issue.scenes[0],\n        implementation: issue.suggestions,\n        relatedPlotHoles: []\n      };\n      suggestions.push(suggestion);\n    }\n    \n    // Generate suggestions for character inconsistencies\n    for (const inconsistency of characterInconsistencies) {\n      const suggestion: PlotHoleSuggestion = {\n        id: `suggestion_${inconsistency.id}`,\n        type: 'character_development',\n        priority: this.mapSeverityToPriority(inconsistency.severity),\n        description: `Fix character inconsistency: ${inconsistency.description}`,\n        targetScene: inconsistency.scenes[0],\n        implementation: inconsistency.suggestions,\n        relatedPlotHoles: []\n      };\n      suggestions.push(suggestion);\n    }\n    \n    return suggestions.sort((a, b) => {\n      const priorityOrder = { critical: 4, high: 3, medium: 2, low: 1 };\n      return priorityOrder[b.priority] - priorityOrder[a.priority];\n    });\n  }\n\n  private getSuggestionType(plotHoleType: string): PlotHoleSuggestion['type'] {\n    switch (plotHoleType) {\n      case 'unresolved_thread': return 'add_scene';\n      case 'character_knowledge': return 'character_development';\n      case 'character_ability': return 'character_development';\n      default: return 'modify_scene';\n    }\n  }\n\n  private mapSeverityToPriority(severity: string): PlotHoleSuggestion['priority'] {\n    switch (severity) {\n      case 'critical': return 'critical';\n      case 'high': return 'high';\n      case 'medium': return 'medium';\n      case 'low': return 'low';\n      default: return 'medium';\n    }\n  }\n\n  private calculateConsistencyScore(\n    plotHoles: PlotHole[],\n    continuityIssues: ContinuityIssue[],\n    characterInconsistencies: CharacterInconsistency[]\n  ): number {\n    const totalIssues = plotHoles.length + continuityIssues.length + characterInconsistencies.length;\n    \n    if (totalIssues === 0) return 100;\n    \n    // Weight issues by severity\n    let weightedIssues = 0;\n    \n    for (const plotHole of plotHoles) {\n      weightedIssues += this.getSeverityWeight(plotHole.severity);\n    }\n    \n    for (const issue of continuityIssues) {\n      weightedIssues += this.getSeverityWeight(issue.severity);\n    }\n    \n    for (const inconsistency of characterInconsistencies) {\n      weightedIssues += this.getSeverityWeight(inconsistency.severity);\n    }\n    \n    // Calculate score (0-100)\n    const maxPossibleWeight = totalIssues * 4; // Assuming all issues are critical\n    const score = Math.max(0, 100 - (weightedIssues / maxPossibleWeight) * 100);\n    \n    return Math.round(score);\n  }\n\n  private getSeverityWeight(severity: string): number {\n    switch (severity) {\n      case 'critical': return 4;\n      case 'high': return 3;\n      case 'medium': return 2;\n      case 'low': return 1;\n      default: return 2;\n    }\n  }\n\n  private convertToPlotThread(tracker: PlotThreadTracker): PlotThread {\n    return {\n      id: tracker.id,\n      name: tracker.name,\n      description: tracker.description,\n      introduced: tracker.introduced,\n      resolved: tracker.resolved,\n      status: tracker.status,\n      importance: tracker.importance,\n      relatedCharacters: tracker.relatedCharacters,\n      keyScenes: tracker.keyScenes\n    };\n  }\n\n  // Public API methods\n  async validateStoryConsistency(story: Story): Promise<{ consistent: boolean; issues: string[] }> {\n    const analysis = await this.analyzeStoryForPlotHoles(story);\n    const issues: string[] = [];\n    \n    if (analysis.plotHoles.length > 0) {\n      issues.push(`Found ${analysis.plotHoles.length} plot holes`);\n    }\n    \n    if (analysis.continuityIssues.length > 0) {\n      issues.push(`Found ${analysis.continuityIssues.length} continuity issues`);\n    }\n    \n    if (analysis.characterInconsistencies.length > 0) {\n      issues.push(`Found ${analysis.characterInconsistencies.length} character inconsistencies`);\n    }\n    \n    return {\n      consistent: analysis.overallScore >= 80,\n      issues\n    };\n  }\n\n  async getPlotThreadSummary(story: Story): Promise<PlotThread[]> {\n    const analysis = await this.analyzeStoryForPlotHoles(story);\n    return analysis.plotThreads;\n  }\n}\n\n// Helper classes\nclass CharacterStateTracker {\n  public character: Character;\n  private knowledge: Map<string, number> = new Map(); // knowledge -> scene where acquired\n  private abilities: Map<string, number> = new Map(); // ability -> scene where acquired\n  private relationships: Map<string, { status: string; scene: number }[]> = new Map();\n  private appearances: number[] = [];\n\n  constructor(character: Character) {\n    this.character = character;\n  }\n\n  recordPresence(sceneIndex: number): void {\n    this.appearances.push(sceneIndex);\n  }\n\n  addKnowledge(knowledge: string, sceneIndex: number): void {\n    this.knowledge.set(knowledge, sceneIndex);\n  }\n\n  addAbility(ability: string, sceneIndex: number): void {\n    this.abilities.set(ability, sceneIndex);\n  }\n\n  updateRelationship(otherCharacterId: string, context: string, sceneIndex: number): void {\n    if (!this.relationships.has(otherCharacterId)) {\n      this.relationships.set(otherCharacterId, []);\n    }\n    \n    const relationshipHistory = this.relationships.get(otherCharacterId)!;\n    relationshipHistory.push({\n      status: this.extractRelationshipStatus(context),\n      scene: sceneIndex\n    });\n  }\n\n  private extractRelationshipStatus(context: string): string {\n    const lowerContext = context.toLowerCase();\n    if (lowerContext.includes('love')) return 'love';\n    if (lowerContext.includes('hate')) return 'hate';\n    if (lowerContext.includes('trust')) return 'trust';\n    if (lowerContext.includes('distrust')) return 'distrust';\n    if (lowerContext.includes('friend')) return 'friend';\n    if (lowerContext.includes('enemy')) return 'enemy';\n    return 'neutral';\n  }\n\n  detectKnowledgeInconsistencies(): Array<{ description: string; scenes: number[]; severity: string }> {\n    const inconsistencies: Array<{ description: string; scenes: number[]; severity: string }> = [];\n    \n    // Check for knowledge used before acquisition\n    for (const [knowledge, acquisitionScene] of this.knowledge) {\n      const earlierUses = this.appearances.filter(scene => scene < acquisitionScene);\n      if (earlierUses.length > 0) {\n        inconsistencies.push({\n          description: `uses knowledge \"${knowledge}\" before acquiring it`,\n          scenes: [acquisitionScene, ...earlierUses],\n          severity: 'medium'\n        });\n      }\n    }\n    \n    return inconsistencies;\n  }\n\n  detectAbilityInconsistencies(): Array<{ description: string; scenes: number[]; severity: string }> {\n    const inconsistencies: Array<{ description: string; scenes: number[]; severity: string }> = [];\n    \n    // Check for abilities used before acquisition\n    for (const [ability, acquisitionScene] of this.abilities) {\n      const earlierUses = this.appearances.filter(scene => scene < acquisitionScene);\n      if (earlierUses.length > 0) {\n        inconsistencies.push({\n          description: `uses ability \"${ability}\" before acquiring it`,\n          scenes: [acquisitionScene, ...earlierUses],\n          severity: 'medium'\n        });\n      }\n    }\n    \n    return inconsistencies;\n  }\n\n  detectPersonalityInconsistencies(): Array<{ description: string; scenes: number[]; conflictingTraits: string[]; severity: string }> {\n    // This would be more sophisticated in a real implementation\n    return [];\n  }\n\n  detectMotivationInconsistencies(): Array<{ description: string; scenes: number[]; conflictingMotivations: string[]; severity: string }> {\n    // This would be more sophisticated in a real implementation\n    return [];\n  }\n}\n\nclass WorldElementTracker {\n  private elementName: string;\n  private appearances: Array<{ scene: number; description: string }> = [];\n\n  constructor(elementName: string) {\n    this.elementName = elementName;\n  }\n\n  recordAppearance(sceneIndex: number, description: string): void {\n    this.appearances.push({ scene: sceneIndex, description });\n  }\n\n  detectInconsistencies(): Array<{ description: string; scenes: number[]; conflictingDescriptions: string[]; severity: string }> {\n    const inconsistencies: Array<{ description: string; scenes: number[]; conflictingDescriptions: string[]; severity: string }> = [];\n    \n    // Simple inconsistency detection - in reality, this would be much more sophisticated\n    const descriptions = this.appearances.map(a => a.description);\n    const uniqueDescriptions = [...new Set(descriptions)];\n    \n    if (uniqueDescriptions.length > 1) {\n      inconsistencies.push({\n        description: `has conflicting descriptions across scenes`,\n        scenes: this.appearances.map(a => a.scene),\n        conflictingDescriptions: uniqueDescriptions,\n        severity: 'low'\n      });\n    }\n    \n    return inconsistencies;\n  }\n}\n\ninterface TimelineEvent {\n  sceneIndex: number;\n  description: string;\n  type: string;\n  timestamp: number; // Relative time in days\n}"