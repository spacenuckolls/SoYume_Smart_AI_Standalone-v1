import { Story, Scene, Character, StoryStructure, PlotPoint, StoryArc } from '../../shared/types/Story';

export interface StructureAnalysisResult {
  structure: StoryStructure;
  plotPoints: PlotPoint[];
  pacing: PacingAnalysis;
  suggestions: StructureSuggestion[];
  confidence: number;
}

export interface PacingAnalysis {
  overallPace: 'slow' | 'moderate' | 'fast' | 'uneven';
  tensionCurve: TensionPoint[];
  climaxPosition: number;
  pacingIssues: PacingIssue[];
}

export interface TensionPoint {
  sceneIndex: number;
  tensionLevel: number; // 0-10 scale
  emotionalIntensity: number;
  conflictLevel: number;
}

export interface PacingIssue {
  type: 'slow_start' | 'rushed_climax' | 'sagging_middle' | 'abrupt_ending' | 'uneven_tension';
  severity: 'low' | 'medium' | 'high';
  location: { start: number; end: number };
  description: string;
  suggestions: string[];
}

export interface StructureSuggestion {
  type: 'missing_plot_point' | 'weak_structure' | 'pacing_issue' | 'character_arc';
  priority: 'low' | 'medium' | 'high';
  description: string;
  location?: number;
  actionable: string[];
}

export interface StoryStructureTemplate {
  name: string;
  description: string;
  plotPoints: PlotPointTemplate[];
  expectedLength: { min: number; max: number };
  genre: string[];
}

export interface PlotPointTemplate {
  name: string;
  description: string;
  position: number; // Percentage of story (0-100)
  required: boolean;
  characteristics: string[];
}

export class StoryStructureAnalyzer {
  private structureTemplates: Map<string, StoryStructureTemplate> = new Map();

  constructor() {
    this.initializeStructureTemplates();
  }

  private initializeStructureTemplates(): void {
    // Three-Act Structure
    this.structureTemplates.set('three-act', {
      name: 'Three-Act Structure',
      description: 'Classic three-act dramatic structure',
      plotPoints: [
        {
          name: 'Inciting Incident',
          description: 'The event that sets the story in motion',
          position: 12,
          required: true,
          characteristics: ['introduces_conflict', 'disrupts_status_quo', 'hooks_reader']
        },
        {
          name: 'Plot Point 1',
          description: 'End of Act 1, protagonist commits to the journey',
          position: 25,
          required: true,
          characteristics: ['point_of_no_return', 'enters_new_world', 'stakes_established']
        },
        {
          name: 'Midpoint',
          description: 'Major revelation or reversal at story center',
          position: 50,
          required: true,
          characteristics: ['revelation', 'false_victory', 'raises_stakes', 'character_growth']
        },
        {
          name: 'Plot Point 2',
          description: 'End of Act 2, all seems lost',
          position: 75,
          required: true,
          characteristics: ['dark_moment', 'final_obstacle', 'character_transformation']
        },
        {
          name: 'Climax',
          description: 'Final confrontation and resolution',
          position: 90,
          required: true,
          characteristics: ['final_battle', 'character_proves_growth', 'resolves_conflict']
        }
      ],
      expectedLength: { min: 50000, max: 120000 },
      genre: ['general', 'drama', 'thriller', 'romance']
    });

    // Hero's Journey
    this.structureTemplates.set('heros-journey', {
      name: \"Hero's Journey\",\n      description: 'Joseph Campbell\\'s monomyth structure',\n      plotPoints: [\n        {\n          name: 'Ordinary World',\n          description: 'Hero\\'s normal life before transformation',\n          position: 5,\n          required: true,\n          characteristics: ['establishes_normal', 'shows_character', 'hints_at_need']\n        },\n        {\n          name: 'Call to Adventure',\n          description: 'Hero is presented with a problem or challenge',\n          position: 10,\n          required: true,\n          characteristics: ['introduces_quest', 'disrupts_normal', 'presents_choice']\n        },\n        {\n          name: 'Refusal of the Call',\n          description: 'Hero hesitates or refuses the adventure',\n          position: 15,\n          required: false,\n          characteristics: ['shows_fear', 'establishes_stakes', 'humanizes_hero']\n        },\n        {\n          name: 'Meeting the Mentor',\n          description: 'Hero encounters wise figure who gives advice/magical gifts',\n          position: 20,\n          required: false,\n          characteristics: ['provides_guidance', 'gives_tools', 'encourages_hero']\n        },\n        {\n          name: 'Crossing the Threshold',\n          description: 'Hero commits to the adventure and enters special world',\n          position: 25,\n          required: true,\n          characteristics: ['point_of_no_return', 'enters_special_world', 'faces_first_challenge']\n        },\n        {\n          name: 'Tests, Allies, and Enemies',\n          description: 'Hero faces challenges and makes allies and enemies',\n          position: 40,\n          required: true,\n          characteristics: ['character_development', 'world_building', 'skill_building']\n        },\n        {\n          name: 'Approach to the Inmost Cave',\n          description: 'Hero prepares for major challenge in special world',\n          position: 60,\n          required: true,\n          characteristics: ['preparation', 'team_building', 'final_planning']\n        },\n        {\n          name: 'Ordeal',\n          description: 'Hero faces greatest fear or most difficult challenge',\n          position: 75,\n          required: true,\n          characteristics: ['death_and_rebirth', 'greatest_challenge', 'transformation']\n        },\n        {\n          name: 'Reward',\n          description: 'Hero survives and gains something from the experience',\n          position: 80,\n          required: true,\n          characteristics: ['gains_object', 'new_knowledge', 'character_growth']\n        },\n        {\n          name: 'The Road Back',\n          description: 'Hero begins journey back to ordinary world',\n          position: 85,\n          required: true,\n          characteristics: ['return_journey', 'chase_scene', 'renewed_commitment']\n        },\n        {\n          name: 'Resurrection',\n          description: 'Final test where hero must use everything learned',\n          position: 90,\n          required: true,\n          characteristics: ['final_battle', 'purification', 'transformation_complete']\n        },\n        {\n          name: 'Return with the Elixir',\n          description: 'Hero returns home transformed and able to help others',\n          position: 95,\n          required: true,\n          characteristics: ['returns_home', 'shares_wisdom', 'helps_others']\n        }\n      ],\n      expectedLength: { min: 60000, max: 150000 },\n      genre: ['fantasy', 'adventure', 'sci-fi', 'mythology']\n    });\n\n    // Save the Cat Beat Sheet\n    this.structureTemplates.set('save-the-cat', {\n      name: 'Save the Cat',\n      description: 'Blake Snyder\\'s 15-beat structure',\n      plotPoints: [\n        {\n          name: 'Opening Image',\n          description: 'Visual that represents the struggle & tone of the story',\n          position: 1,\n          required: true,\n          characteristics: ['sets_tone', 'visual_metaphor', 'story_theme']\n        },\n        {\n          name: 'Theme Stated',\n          description: 'What your story is about; the message',\n          position: 5,\n          required: true,\n          characteristics: ['states_theme', 'life_lesson', 'moral_premise']\n        },\n        {\n          name: 'Set-Up',\n          description: 'Introduce hero, stakes, and goal',\n          position: 10,\n          required: true,\n          characteristics: ['introduces_hero', 'establishes_world', 'shows_flaw']\n        },\n        {\n          name: 'Catalyst',\n          description: 'Life-changing event that happens TO the hero',\n          position: 12,\n          required: true,\n          characteristics: ['inciting_incident', 'disrupts_life', 'creates_urgency']\n        },\n        {\n          name: 'Debate',\n          description: 'Hero hesitates, weighs options',\n          position: 17,\n          required: true,\n          characteristics: ['internal_conflict', 'weighs_options', 'shows_stakes']\n        },\n        {\n          name: 'Break into Two',\n          description: 'Hero makes choice and enters Act 2',\n          position: 25,\n          required: true,\n          characteristics: ['active_choice', 'enters_new_world', 'commits_to_goal']\n        },\n        {\n          name: 'B Story',\n          description: 'Subplot that carries theme of the story',\n          position: 30,\n          required: false,\n          characteristics: ['love_story', 'theme_carrier', 'character_growth']\n        },\n        {\n          name: 'Fun and Games',\n          description: 'Promise of the premise; why we came to see the movie',\n          position: 40,\n          required: true,\n          characteristics: ['genre_elements', 'audience_expectations', 'exploration']\n        },\n        {\n          name: 'Midpoint',\n          description: 'Apparent victory or defeat',\n          position: 50,\n          required: true,\n          characteristics: ['false_victory', 'stakes_raised', 'time_clock']\n        },\n        {\n          name: 'Bad Guys Close In',\n          description: 'Doubt, jealousy, fear, foes both external and internal',\n          position: 62,\n          required: true,\n          characteristics: ['increasing_pressure', 'internal_doubt', 'external_forces']\n        },\n        {\n          name: 'All Is Lost',\n          description: 'Opposite of Midpoint; apparent defeat',\n          position: 75,\n          required: true,\n          characteristics: ['dark_moment', 'hope_lost', 'whiff_of_death']\n        },\n        {\n          name: 'Dark Night of the Soul',\n          description: 'Hero\\'s reaction to All Is Lost',\n          position: 80,\n          required: true,\n          characteristics: ['emotional_low', 'contemplation', 'final_lesson']\n        },\n        {\n          name: 'Break into Three',\n          description: 'Thanks to new info, hero has the solution',\n          position: 85,\n          required: true,\n          characteristics: ['new_plan', 'synthesis', 'final_push']\n        },\n        {\n          name: 'Finale',\n          description: 'Hero confronts problem and solves it',\n          position: 92,\n          required: true,\n          characteristics: ['final_battle', 'applies_lesson', 'transformation']\n        },\n        {\n          name: 'Final Image',\n          description: 'Opposite of Opening Image; proof of change',\n          position: 99,\n          required: true,\n          characteristics: ['transformation_proof', 'visual_bookend', 'new_world']\n        }\n      ],\n      expectedLength: { min: 80000, max: 100000 },\n      genre: ['screenplay', 'commercial_fiction', 'thriller', 'romance']\n    });\n\n    // Kishōtenketsu (Four-Act Structure)\n    this.structureTemplates.set('kishotenketsu', {\n      name: 'Kishōtenketsu',\n      description: 'Japanese four-act structure without conflict',\n      plotPoints: [\n        {\n          name: 'Ki (Introduction)',\n          description: 'Introduces characters, setting, and situation',\n          position: 25,\n          required: true,\n          characteristics: ['character_introduction', 'world_building', 'establishes_normal']\n        },\n        {\n          name: 'Shō (Development)',\n          description: 'Develops the situation and characters',\n          position: 50,\n          required: true,\n          characteristics: ['character_development', 'situation_expansion', 'relationship_building']\n        },\n        {\n          name: 'Ten (Twist)',\n          description: 'Introduces unexpected element or perspective',\n          position: 75,\n          required: true,\n          characteristics: ['unexpected_element', 'new_perspective', 'complication']\n        },\n        {\n          name: 'Ketsu (Conclusion)',\n          description: 'Resolves the story with new understanding',\n          position: 95,\n          required: true,\n          characteristics: ['resolution', 'new_understanding', 'emotional_conclusion']\n        }\n      ],\n      expectedLength: { min: 30000, max: 80000 },\n      genre: ['literary', 'slice_of_life', 'contemplative', 'eastern_narrative']\n    });\n  }\n\n  async analyzeStoryStructure(story: Story, preferredStructure?: string): Promise<StructureAnalysisResult> {\n    // Determine the best structure template to use\n    const structureTemplate = this.selectBestStructure(story, preferredStructure);\n    \n    // Analyze the story against the template\n    const plotPoints = await this.identifyPlotPoints(story, structureTemplate);\n    const pacing = await this.analyzePacing(story, plotPoints);\n    const suggestions = await this.generateStructureSuggestions(story, structureTemplate, plotPoints, pacing);\n    \n    // Calculate confidence based on how well the story fits the structure\n    const confidence = this.calculateStructureConfidence(story, structureTemplate, plotPoints);\n    \n    return {\n      structure: {\n        type: structureTemplate.name,\n        template: structureTemplate,\n        adherence: confidence\n      },\n      plotPoints,\n      pacing,\n      suggestions,\n      confidence\n    };\n  }\n\n  private selectBestStructure(story: Story, preferredStructure?: string): StoryStructureTemplate {\n    if (preferredStructure && this.structureTemplates.has(preferredStructure)) {\n      return this.structureTemplates.get(preferredStructure)!;\n    }\n\n    // Analyze story characteristics to suggest best structure\n    const wordCount = this.estimateWordCount(story);\n    const genre = story.genre || 'general';\n    const hasConflict = this.detectConflictElements(story);\n    \n    // Score each template based on story characteristics\n    let bestTemplate = this.structureTemplates.get('three-act')!;\n    let bestScore = 0;\n    \n    for (const [key, template] of this.structureTemplates) {\n      let score = 0;\n      \n      // Word count fit\n      if (wordCount >= template.expectedLength.min && wordCount <= template.expectedLength.max) {\n        score += 3;\n      } else if (wordCount < template.expectedLength.max * 1.2 && wordCount > template.expectedLength.min * 0.8) {\n        score += 1;\n      }\n      \n      // Genre fit\n      if (template.genre.includes(genre) || template.genre.includes('general')) {\n        score += 2;\n      }\n      \n      // Conflict-based vs non-conflict structures\n      if (key === 'kishotenketsu' && !hasConflict) {\n        score += 2;\n      } else if (key !== 'kishotenketsu' && hasConflict) {\n        score += 1;\n      }\n      \n      if (score > bestScore) {\n        bestScore = score;\n        bestTemplate = template;\n      }\n    }\n    \n    return bestTemplate;\n  }\n\n  private async identifyPlotPoints(story: Story, template: StoryStructureTemplate): Promise<PlotPoint[]> {\n    const scenes = story.scenes || [];\n    const totalScenes = scenes.length;\n    const plotPoints: PlotPoint[] = [];\n    \n    for (const plotPointTemplate of template.plotPoints) {\n      const expectedPosition = Math.floor((plotPointTemplate.position / 100) * totalScenes);\n      const searchRange = Math.max(1, Math.floor(totalScenes * 0.1)); // 10% range\n      \n      // Search for the plot point in the expected range\n      const foundPlotPoint = await this.findPlotPointInRange(\n        scenes,\n        expectedPosition,\n        searchRange,\n        plotPointTemplate\n      );\n      \n      if (foundPlotPoint) {\n        plotPoints.push(foundPlotPoint);\n      } else if (plotPointTemplate.required) {\n        // Create a missing plot point entry\n        plotPoints.push({\n          name: plotPointTemplate.name,\n          description: plotPointTemplate.description,\n          position: expectedPosition,\n          sceneIndex: expectedPosition,\n          confidence: 0,\n          missing: true,\n          characteristics: plotPointTemplate.characteristics\n        });\n      }\n    }\n    \n    return plotPoints.sort((a, b) => a.position - b.position);\n  }\n\n  private async findPlotPointInRange(\n    scenes: Scene[],\n    expectedPosition: number,\n    searchRange: number,\n    template: PlotPointTemplate\n  ): Promise<PlotPoint | null> {\n    const startIndex = Math.max(0, expectedPosition - searchRange);\n    const endIndex = Math.min(scenes.length - 1, expectedPosition + searchRange);\n    \n    let bestMatch: PlotPoint | null = null;\n    let bestScore = 0;\n    \n    for (let i = startIndex; i <= endIndex; i++) {\n      const scene = scenes[i];\n      const score = await this.scoreSceneForPlotPoint(scene, template);\n      \n      if (score > bestScore && score > 0.3) { // Minimum confidence threshold\n        bestScore = score;\n        bestMatch = {\n          name: template.name,\n          description: template.description,\n          position: (i / scenes.length) * 100,\n          sceneIndex: i,\n          confidence: score,\n          missing: false,\n          characteristics: template.characteristics,\n          scene: scene\n        };\n      }\n    }\n    \n    return bestMatch;\n  }\n\n  private async scoreSceneForPlotPoint(scene: Scene, template: PlotPointTemplate): Promise<number> {\n    let score = 0;\n    const sceneText = scene.content || '';\n    const sceneTitle = scene.title || '';\n    const sceneSummary = scene.summary || '';\n    \n    // Analyze scene characteristics against template characteristics\n    for (const characteristic of template.characteristics) {\n      const characteristicScore = await this.analyzeCharacteristic(sceneText, sceneTitle, sceneSummary, characteristic);\n      score += characteristicScore;\n    }\n    \n    // Normalize score\n    return Math.min(1, score / template.characteristics.length);\n  }\n\n  private async analyzeCharacteristic(text: string, title: string, summary: string, characteristic: string): Promise<number> {\n    const combinedText = `${title} ${summary} ${text}`.toLowerCase();\n    \n    // Define keyword patterns for different characteristics\n    const characteristicPatterns: Record<string, string[]> = {\n      'introduces_conflict': ['conflict', 'problem', 'challenge', 'obstacle', 'tension', 'disagreement'],\n      'disrupts_status_quo': ['change', 'different', 'unexpected', 'surprise', 'disruption', 'break'],\n      'hooks_reader': ['mystery', 'question', 'intrigue', 'curious', 'wonder', 'suspense'],\n      'point_of_no_return': ['decision', 'choice', 'commit', 'no turning back', 'must', 'have to'],\n      'enters_new_world': ['new', 'different', 'strange', 'unfamiliar', 'journey', 'travel'],\n      'stakes_established': ['important', 'matter', 'consequence', 'risk', 'danger', 'lose'],\n      'revelation': ['discover', 'realize', 'learn', 'reveal', 'truth', 'secret'],\n      'false_victory': ['win', 'success', 'triumph', 'victory', 'achieve', 'accomplish'],\n      'raises_stakes': ['worse', 'danger', 'risk', 'threat', 'escalate', 'intensify'],\n      'character_growth': ['learn', 'grow', 'change', 'understand', 'mature', 'develop'],\n      'dark_moment': ['lost', 'defeat', 'fail', 'hopeless', 'despair', 'give up'],\n      'final_obstacle': ['last', 'final', 'ultimate', 'biggest', 'greatest', 'hardest'],\n      'character_transformation': ['become', 'transform', 'change', 'new person', 'different'],\n      'final_battle': ['fight', 'battle', 'confrontation', 'showdown', 'face', 'against'],\n      'resolves_conflict': ['resolve', 'solve', 'end', 'finish', 'complete', 'conclusion']\n    };\n    \n    const patterns = characteristicPatterns[characteristic] || [];\n    let matches = 0;\n    \n    for (const pattern of patterns) {\n      if (combinedText.includes(pattern)) {\n        matches++;\n      }\n    }\n    \n    // Return score based on pattern matches\n    return patterns.length > 0 ? matches / patterns.length : 0;\n  }\n\n  private async analyzePacing(story: Story, plotPoints: PlotPoint[]): Promise<PacingAnalysis> {\n    const scenes = story.scenes || [];\n    const tensionCurve = await this.calculateTensionCurve(scenes);\n    const climaxPosition = this.findClimaxPosition(plotPoints, tensionCurve);\n    const overallPace = this.assessOverallPace(scenes, tensionCurve);\n    const pacingIssues = this.identifyPacingIssues(scenes, tensionCurve, plotPoints);\n    \n    return {\n      overallPace,\n      tensionCurve,\n      climaxPosition,\n      pacingIssues\n    };\n  }\n\n  private async calculateTensionCurve(scenes: Scene[]): Promise<TensionPoint[]> {\n    const tensionPoints: TensionPoint[] = [];\n    \n    for (let i = 0; i < scenes.length; i++) {\n      const scene = scenes[i];\n      const tensionLevel = await this.analyzeTensionLevel(scene);\n      const emotionalIntensity = await this.analyzeEmotionalIntensity(scene);\n      const conflictLevel = await this.analyzeConflictLevel(scene);\n      \n      tensionPoints.push({\n        sceneIndex: i,\n        tensionLevel,\n        emotionalIntensity,\n        conflictLevel\n      });\n    }\n    \n    return tensionPoints;\n  }\n\n  private async analyzeTensionLevel(scene: Scene): Promise<number> {\n    const content = scene.content || '';\n    const tensionKeywords = [\n      'tension', 'suspense', 'anxiety', 'worry', 'fear', 'nervous',\n      'edge', 'anticipation', 'dread', 'unease', 'stress', 'pressure'\n    ];\n    \n    const actionKeywords = [\n      'run', 'chase', 'fight', 'battle', 'struggle', 'race',\n      'urgent', 'quick', 'fast', 'hurry', 'rush', 'immediate'\n    ];\n    \n    let score = 0;\n    const words = content.toLowerCase().split(/\\s+/);\n    \n    for (const word of words) {\n      if (tensionKeywords.includes(word)) score += 2;\n      if (actionKeywords.includes(word)) score += 1;\n    }\n    \n    // Normalize to 0-10 scale\n    return Math.min(10, (score / words.length) * 1000);\n  }\n\n  private async analyzeEmotionalIntensity(scene: Scene): Promise<number> {\n    const content = scene.content || '';\n    const highIntensityEmotions = [\n      'love', 'hate', 'rage', 'fury', 'terror', 'ecstasy',\n      'despair', 'joy', 'anguish', 'passion', 'devastated', 'elated'\n    ];\n    \n    const mediumIntensityEmotions = [\n      'happy', 'sad', 'angry', 'afraid', 'excited', 'worried',\n      'pleased', 'upset', 'concerned', 'hopeful', 'disappointed'\n    ];\n    \n    let score = 0;\n    const words = content.toLowerCase().split(/\\s+/);\n    \n    for (const word of words) {\n      if (highIntensityEmotions.includes(word)) score += 3;\n      if (mediumIntensityEmotions.includes(word)) score += 1;\n    }\n    \n    return Math.min(10, (score / words.length) * 1000);\n  }\n\n  private async analyzeConflictLevel(scene: Scene): Promise<number> {\n    const content = scene.content || '';\n    const conflictKeywords = [\n      'argue', 'fight', 'disagree', 'oppose', 'conflict', 'struggle',\n      'against', 'versus', 'battle', 'confrontation', 'challenge', 'obstacle'\n    ];\n    \n    let score = 0;\n    const words = content.toLowerCase().split(/\\s+/);\n    \n    for (const word of words) {\n      if (conflictKeywords.includes(word)) score += 1;\n    }\n    \n    return Math.min(10, (score / words.length) * 1000);\n  }\n\n  private findClimaxPosition(plotPoints: PlotPoint[], tensionCurve: TensionPoint[]): number {\n    // Look for climax plot point first\n    const climaxPoint = plotPoints.find(p => \n      p.name.toLowerCase().includes('climax') || \n      p.characteristics.includes('final_battle')\n    );\n    \n    if (climaxPoint && !climaxPoint.missing) {\n      return climaxPoint.sceneIndex;\n    }\n    \n    // Find highest tension point\n    let maxTension = 0;\n    let climaxIndex = 0;\n    \n    for (const point of tensionCurve) {\n      const totalTension = point.tensionLevel + point.emotionalIntensity + point.conflictLevel;\n      if (totalTension > maxTension) {\n        maxTension = totalTension;\n        climaxIndex = point.sceneIndex;\n      }\n    }\n    \n    return climaxIndex;\n  }\n\n  private assessOverallPace(scenes: Scene[], tensionCurve: TensionPoint[]): 'slow' | 'moderate' | 'fast' | 'uneven' {\n    if (tensionCurve.length === 0) return 'moderate';\n    \n    const averageTension = tensionCurve.reduce((sum, point) => \n      sum + point.tensionLevel + point.emotionalIntensity + point.conflictLevel, 0\n    ) / (tensionCurve.length * 3);\n    \n    // Calculate variance to detect uneven pacing\n    const variance = tensionCurve.reduce((sum, point) => {\n      const totalTension = (point.tensionLevel + point.emotionalIntensity + point.conflictLevel) / 3;\n      return sum + Math.pow(totalTension - averageTension, 2);\n    }, 0) / tensionCurve.length;\n    \n    if (variance > 4) return 'uneven';\n    if (averageTension < 3) return 'slow';\n    if (averageTension > 7) return 'fast';\n    return 'moderate';\n  }\n\n  private identifyPacingIssues(scenes: Scene[], tensionCurve: TensionPoint[], plotPoints: PlotPoint[]): PacingIssue[] {\n    const issues: PacingIssue[] = [];\n    \n    // Check for slow start\n    if (tensionCurve.length > 0) {\n      const firstQuarter = tensionCurve.slice(0, Math.floor(tensionCurve.length / 4));\n      const avgStartTension = firstQuarter.reduce((sum, point) => \n        sum + point.tensionLevel + point.emotionalIntensity + point.conflictLevel, 0\n      ) / (firstQuarter.length * 3);\n      \n      if (avgStartTension < 2) {\n        issues.push({\n          type: 'slow_start',\n          severity: 'medium',\n          location: { start: 0, end: firstQuarter.length - 1 },\n          description: 'The story starts slowly with low tension and engagement',\n          suggestions: [\n            'Consider starting closer to the inciting incident',\n            'Add more conflict or intrigue to the opening scenes',\n            'Introduce compelling questions or mysteries early'\n          ]\n        });\n      }\n    }\n    \n    // Check for sagging middle\n    if (tensionCurve.length > 4) {\n      const middleStart = Math.floor(tensionCurve.length * 0.3);\n      const middleEnd = Math.floor(tensionCurve.length * 0.7);\n      const middleSection = tensionCurve.slice(middleStart, middleEnd);\n      \n      const avgMiddleTension = middleSection.reduce((sum, point) => \n        sum + point.tensionLevel + point.emotionalIntensity + point.conflictLevel, 0\n      ) / (middleSection.length * 3);\n      \n      if (avgMiddleTension < 3) {\n        issues.push({\n          type: 'sagging_middle',\n          severity: 'high',\n          location: { start: middleStart, end: middleEnd },\n          description: 'The middle section lacks tension and forward momentum',\n          suggestions: [\n            'Add subplot complications or character conflicts',\n            'Introduce new obstacles or revelations',\n            'Increase stakes or add time pressure',\n            'Develop character relationships and internal conflicts'\n          ]\n        });\n      }\n    }\n    \n    // Check for rushed climax\n    const climaxPoint = plotPoints.find(p => p.characteristics.includes('final_battle'));\n    if (climaxPoint && !climaxPoint.missing) {\n      const climaxIndex = climaxPoint.sceneIndex;\n      const storyLength = scenes.length;\n      \n      if (climaxIndex > storyLength * 0.95) {\n        issues.push({\n          type: 'rushed_climax',\n          severity: 'high',\n          location: { start: climaxIndex, end: storyLength - 1 },\n          description: 'The climax occurs too late, leaving insufficient time for resolution',\n          suggestions: [\n            'Move the climax earlier to allow for proper resolution',\n            'Extend the story to provide adequate falling action',\n            'Ensure the climax has sufficient buildup and consequences'\n          ]\n        });\n      }\n    }\n    \n    return issues;\n  }\n\n  private async generateStructureSuggestions(\n    story: Story,\n    template: StoryStructureTemplate,\n    plotPoints: PlotPoint[],\n    pacing: PacingAnalysis\n  ): Promise<StructureSuggestion[]> {\n    const suggestions: StructureSuggestion[] = [];\n    \n    // Check for missing required plot points\n    const missingPlotPoints = plotPoints.filter(p => p.missing && template.plotPoints.find(t => t.name === p.name)?.required);\n    \n    for (const missingPoint of missingPlotPoints) {\n      suggestions.push({\n        type: 'missing_plot_point',\n        priority: 'high',\n        description: `Missing required plot point: ${missingPoint.name}`,\n        location: missingPoint.sceneIndex,\n        actionable: [\n          `Add a scene around position ${missingPoint.sceneIndex} that serves as the ${missingPoint.name}`,\n          `Ensure this scene ${missingPoint.description.toLowerCase()}`,\n          `Include elements: ${missingPoint.characteristics.join(', ')}`\n        ]\n      });\n    }\n    \n    // Add pacing-related suggestions\n    for (const issue of pacing.pacingIssues) {\n      suggestions.push({\n        type: 'pacing_issue',\n        priority: issue.severity === 'high' ? 'high' : 'medium',\n        description: issue.description,\n        location: issue.location.start,\n        actionable: issue.suggestions\n      });\n    }\n    \n    // Check structure adherence\n    const adherenceScore = this.calculateStructureConfidence(story, template, plotPoints);\n    if (adherenceScore < 0.6) {\n      suggestions.push({\n        type: 'weak_structure',\n        priority: 'medium',\n        description: `Story structure doesn't strongly follow ${template.name} pattern`,\n        actionable: [\n          `Consider restructuring to better fit ${template.name} beats`,\n          'Review plot point placement and timing',\n          'Ensure each act serves its intended purpose'\n        ]\n      });\n    }\n    \n    return suggestions.sort((a, b) => {\n      const priorityOrder = { high: 3, medium: 2, low: 1 };\n      return priorityOrder[b.priority] - priorityOrder[a.priority];\n    });\n  }\n\n  private calculateStructureConfidence(story: Story, template: StoryStructureTemplate, plotPoints: PlotPoint[]): number {\n    const requiredPlotPoints = template.plotPoints.filter(p => p.required);\n    const foundRequiredPoints = plotPoints.filter(p => !p.missing && requiredPlotPoints.some(r => r.name === p.name));\n    \n    const structuralScore = foundRequiredPoints.length / requiredPlotPoints.length;\n    const confidenceScore = plotPoints.reduce((sum, point) => sum + (point.confidence || 0), 0) / plotPoints.length;\n    \n    return (structuralScore + confidenceScore) / 2;\n  }\n\n  private estimateWordCount(story: Story): number {\n    const scenes = story.scenes || [];\n    let totalWords = 0;\n    \n    for (const scene of scenes) {\n      const content = scene.content || '';\n      totalWords += content.split(/\\s+/).length;\n    }\n    \n    return totalWords;\n  }\n\n  private detectConflictElements(story: Story): boolean {\n    const scenes = story.scenes || [];\n    const conflictKeywords = [\n      'conflict', 'fight', 'battle', 'struggle', 'oppose', 'against',\n      'enemy', 'villain', 'antagonist', 'problem', 'challenge', 'obstacle'\n    ];\n    \n    for (const scene of scenes) {\n      const content = (scene.content || '').toLowerCase();\n      for (const keyword of conflictKeywords) {\n        if (content.includes(keyword)) {\n          return true;\n        }\n      }\n    }\n    \n    return false;\n  }\n\n  // Public API methods\n  getAvailableStructures(): StoryStructureTemplate[] {\n    return Array.from(this.structureTemplates.values());\n  }\n\n  getStructureTemplate(name: string): StoryStructureTemplate | null {\n    return this.structureTemplates.get(name) || null;\n  }\n\n  async validateStructure(story: Story, structureName: string): Promise<{ valid: boolean; issues: string[] }> {\n    const template = this.structureTemplates.get(structureName);\n    if (!template) {\n      return { valid: false, issues: ['Unknown structure template'] };\n    }\n    \n    const analysis = await this.analyzeStoryStructure(story, structureName);\n    const issues: string[] = [];\n    \n    if (analysis.confidence < 0.5) {\n      issues.push('Story does not strongly follow the selected structure');\n    }\n    \n    const missingRequired = analysis.plotPoints.filter(p => p.missing && \n      template.plotPoints.find(t => t.name === p.name)?.required\n    );\n    \n    if (missingRequired.length > 0) {\n      issues.push(`Missing required plot points: ${missingRequired.map(p => p.name).join(', ')}`);\n    }\n    \n    if (analysis.pacing.pacingIssues.filter(i => i.severity === 'high').length > 0) {\n      issues.push('Story has significant pacing issues');\n    }\n    \n    return {\n      valid: issues.length === 0,\n      issues\n    };\n  }\n}"